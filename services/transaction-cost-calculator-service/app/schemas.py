from pydantic import BaseModel, Field
from datetime import date, datetime
from typing import Optional
import uuid

# Re-use existing Transaction schema if available or define it to match common/models.py
# Assuming Transaction schema is not directly in this service's schemas.py yet,
# but rather common/models.py. For API input/output, we should use Pydantic schemas.
# Let's define minimal Transaction-related schemas for this service if needed for API.

class TransactionBase(BaseModel):
    transaction_id: str
    portfolio_id: str
    instrument_id: str
    transaction_date: date
    transaction_type: str
    quantity: float
    price: float
    currency: str
    trade_fee: Optional[float] = None
    settlement_date: Optional[date] = None

class TransactionCreate(TransactionBase):
    pass

class TransactionRead(TransactionBase):
    created_at: datetime
    class Config:
        from_attributes = True # Or orm_mode = True for Pydantic v1

# TransactionCost Schemas
class TransactionCostBase(BaseModel):
    transaction_id: str
    portfolio_id: str
    instrument_id: str
    transaction_date: date
    cost_amount: float
    cost_currency: str
    calculation_date: datetime = Field(default_factory=lambda: datetime.now()) # Default for creation

class TransactionCostCreate(TransactionCostBase):
    # For creation, ID will be generated by the database
    pass

class TransactionCostRead(TransactionCostBase):
    id: uuid.UUID
    created_at: datetime # This will be populated when reading from DB

    class Config:
        from_attributes = True # Enable ORM mode for Pydantic v2